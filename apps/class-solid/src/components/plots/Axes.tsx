// Code generated by AI and checked/modified for correctness

import type { ScaleLinear } from "d3";
import * as d3 from "d3";
import { For } from "solid-js";

interface AxisProps {
  scale: ScaleLinear<number, number>;
  transform?: string;
  tickCount?: number;
  label?: string;
  tickValues?: number[];
  tickFormat?: (n: number | { valueOf(): number }) => string;
  decreasing?: boolean;
}

const ticks = (props: AxisProps) => {
  const domain = props.scale.domain();
  const generateTicks = (domain = [0, 1], tickCount = 5) => {
    const step = (domain[1] - domain[0]) / (tickCount - 1);
    return [...Array(10).keys()].map((i) => domain[0] + i * step);
  };

  const values = props.tickValues
    ? props.tickValues.filter((x) => x >= domain[0] && x <= domain[1])
    : generateTicks(domain, props.tickCount);
  return values.map((value) => ({ value, position: props.scale(value) }));
};

export const AxisBottom = (props: AxisProps) => {
  const format = props.tickFormat ? props.tickFormat : d3.format(".3g");
  return (
    <g transform={props.transform}>
      <line
        x1={props.scale.range()[0]}
        x2={props.scale.range()[1]}
        y1="0"
        y2="0"
        stroke="currentColor"
      />
      <For each={ticks(props)}>
        {(tick) => (
          <g transform={`translate(${tick.position}, 0)`}>
            <line y2="6" stroke="currentColor" />
            <text y="9" dy="0.71em" text-anchor="middle">
              {format(tick.value)}
            </text>
          </g>
        )}
      </For>
      <text x={props.scale.range()[1]} y="9" dy="2em" text-anchor="end">
        {props.label}
      </text>
    </g>
  );
};

export const AxisLeft = (props: AxisProps) => {
  const format = props.tickFormat ? props.tickFormat : d3.format(".0f");
  const yAnchor = props.decreasing ? 0 : 1;
  return (
    <g transform={props.transform}>
      <line
        x1={0}
        x2={0}
        y1={props.scale.range()[0]}
        y2={props.scale.range()[1]}
        stroke="currentColor"
      />
      <For each={ticks(props)}>
        {(tick) => (
          <g transform={`translate(0, ${tick.position})`}>
            <line x2="-6" stroke="currentColor" />
            <text x="-9" dy="0.32em" text-anchor="end">
              {format(tick.value)}
            </text>
          </g>
        )}
      </For>
      <text
        y={props.scale.range()[yAnchor]}
        text-anchor="end"
        transform="translate(-45, 0) rotate(-90)"
      >
        {props.label}
      </text>
    </g>
  );
};

/**
 * Calculate a "nice" step size by rounding up to the nearest power of 10
 * Snap the min and max to the nearest multiple of step
 */
export function getNiceAxisLimits(data: number[]): [number, number] {
  const max = Math.max(...data);
  const min = Math.min(...data);
  const range = max - min;
  const step = 10 ** Math.floor(Math.log10(range));

  const niceMin = Math.floor(min / step) * step;
  const niceMax = Math.ceil(max / step) * step;

  return [niceMin, niceMax];
}
